FORK(2):
pid_t fork() - системный вызов, который создает процесс. Единственный способ создать процесс в UNIX. При выполнении fork создается новый процесс на основе родительского:
user area в ядре полностью копируется, с некоторыми изменениями(к примеру, pid, ppid меняются на логичные для нового процесса), а виртуальное пространство родительского
процесса по принципу copy-on-write перенимается у родительского процесса. Небольшое исключение - динамическая память может быть разделяемой, в зависимости от атрибутов
(процесса, полагаю).

Возвращаемое значение: 0, если это дочерний процесс. pid порожденного процесса, если это родительский процесс. И -1, если произошла ошибка, к примеру, исчерпана квота по
количеству процессов, или по количеству потомков у одного процесса, или если создать потомка не получилось ввиду того, что закончилась память.((!) максимальное количество 
одновременно работающих процессов на один реальный идентификатор пользователя определяется константой CHILD_MAX.) При ошибке также устанавливается errno. 

Принцип copy-on-write: необходимо вспомнить про страничную организацию виртуальной памяти. Это когда единицей отображения виртуальных адресов на физические является не
1 бит, а какое-то фиксировнное количество бит, что важно, непрерывных в памяти. (В ядре у страниц есть дескрипторы, можно почитать на вики 
https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%80_%D1%81%D0%B5%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%B0 или попробовать найти у иртегова
но последнее не гарантирует результат. Так вот в этих дескрипторах записана в том числе и вся необходимая  информация для следующего механизма). По началу всё виртуальное 
пространство родительского и порожденного процесса полностью разделяемые, но защищенные от записи. Если одним из процессов инициировано изменение какой-либо страницы(то 
бишь единицы отображения виртуальных адресов на физические), это влечет ошибку, и управление передается в ядро, которое, в свою очередь, запускает обработчик этой ошибки. 
Но так как это не защита от записи как таковая, а защита, соответствующая механизму copy-on-write, в ответ на эту ошибку создается копия этой страницы, и в ней уже происх
одят требуемые изменения. Виртуальный адрес ячеек, соотв. измененной странице меняется на вновь созданные. 

Исполнение дочернего процесса начинается со следующей инструкции после форка. 

Дочерний процесс не наследует:
- pid - идентификатор
- ppid - идентификатор родительского процесса 
- Захваченные участки файлов
- Нити исполнения (кроме той, которая вызывала fork) - т.е. когда сделаем fork многопоточного процесса, у него наследуется
только та нить, которая сделала forkм 

Про дескрипторы: https://www.ibm.com/docs/ru/aix/7.2?topic=volumes-using-file-descriptors
