FORK(2):
pid_t fork() - системный вызов, который создает процесс. Единственный способ создать процесс в UNIX. При выполнении fork создается новый процесс на основе родительского:
user area в ядре полностью копируется, с некоторыми изменениями(к примеру, pid, ppid меняются на логичные для нового процесса), а виртуальное пространство родительского
процесса по принципу copy-on-write перенимается у родительского процесса. Небольшое исключение - динамическая память может быть разделяемой, в зависимости от атрибутов
(процесса, полагаю).

Возвращаемое значение: 0, если это дочерний процесс. pid порожденного процесса, если это родительский процесс. И -1, если произошла ошибка, к примеру, исчерпана квота по
количеству процессов, или по количеству потомков у одного процесса, или если создать потомка не получилось ввиду того, что закончилась память в ядре.((!) максимальное количество 
одновременно работающих процессов на один реальный идентификатор пользователя определяется константой CHILD_MAX.) При ошибке также устанавливается errno. 

Принцип copy-on-write: необходимо вспомнить про страничную организацию виртуальной памяти. Это когда единицей отображения виртуальных адресов на физические является не
1 бит, а какое-то фиксировнное количество бит, что важно, непрерывных в памяти. (В ядре у страниц есть дескрипторы, можно почитать на вики 
https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D1%80_%D1%81%D0%B5%D0%B3%D0%BC%D0%B5%D0%BD%D1%82%D0%B0 или попробовать найти у иртегова
но последнее не гарантирует результат. Так вот в этих дескрипторах записана в том числе и вся необходимая  информация для следующего механизма). По началу всё виртуальное 
пространство родительского и порожденного процесса полностью разделяемые, но защищенные от записи. Если одним из процессов инициировано изменение какой-либо страницы(то 
бишь единицы отображения виртуальных адресов на физические), это влечет ошибку, и управление передается в ядро, которое, в свою очередь, запускает обработчик этой ошибки. 
Но так как это не защита от записи как таковая, а защита, соответствующая механизму copy-on-write, в ответ на эту ошибку создается копия этой страницы, и в ней уже происх
одят требуемые изменения. Виртуальный адрес ячеек, соотв. измененной странице меняется на вновь созданные. 

Исполнение дочернего процесса начинается со следующей инструкции после форка. 

Дочерний процесс не наследует:
- pid - идентификатор
- ppid - идентификатор родительского процесса 
- Захваченные участки файлов
- Нити исполнения (кроме той, которая вызывала fork) - т.е. когда сделаем fork многопоточного процесса, у него наследуется
только та нить, которая сделала forkм 

Про дескрипторы: https://www.ibm.com/docs/ru/aix/7.2?topic=volumes-using-file-descriptors

Вопрос про файловые дескрипторы: таблица открытых файлов, содержащая дескрипторы открытых файлов в нашем процессе, хранится в пользовательской области, которая 
копируется при вызове fork. Таким образом, закрытие файлового дескриптора в родительском или дочернем процессе никак не повлияет на потомка/родителя. 

WAIT(2): 
pid_t wait(int *stat_loc); замораживает выполнение вызвавшего его процесса до тех пор, пока дочерний процесс не завершится. Возвращается как только один из потомков 
завершился. Также wait позволяет системе освободить связанные с дочерним процессом ресурсы. Если не использовать wait, то процесс станет зомби, то есть завершенным 
процессом с не освобожденными ресурсами и с активным слотом в таблице процессов в ядре при завершенном процессе. Если на момент вызова wait какой-либо из дочерних 
процессов уже был завершен, wait тут же возвращается и освобождает ресурсы связанные с завершившимися дочерними процессами.

Из man'a: In the case of a terminated child, performing a wait allows the system to release the resources associated with the child
Перевод: в случае с завершением дочернего процесса, выполнение wait позволяет системе освободить ассоциируемые с ребенком ресурсы 

Возвращаемое значение: в случае успеха возвращается pid завершившегося проесса, в случае ошибки -1 и устанавливается код ошибки в errno. 

Я полагаю, что если у нас есть несколько завершившихся подпроцессов на момент вызова wait, то освобождение ресурсов будет только из под одного процесса. Оно и логично, 
так как мы получили информацию только об одном процессе, оставшиеся так и будут зомби.

Процесс-зомби: дочерний процесс, который завершился, но для которого не был вызван wait, становится так называемым зомби-процессом. Смысл тут такой: то, что процесс
завершился не означает, что информация об этом процессе более не нужна. Соответственно, ядро оставляет некоторое минимальное количество информации о таких процессах 
чтобы позволить родителю позднее использовать её для каких-то своих целей. Но, если родительский процесс завершился, то wait вызван родительским процессом уже явно не 
будет, как и информация о его дочерних процессах уже явно никому не нужна. Это и порождает такую проблему, как зомби-процесс, и она решается следующим образом: как 
известно, у любого процесса в UNIX, корме init, есть родительский процесс. В случаях, если процесс-родитель был завершен и не выполнил wait для своего потомка, или 
если дочерний процесс завершился позже родительского (две крайности одной проблемы) родителем такого процесса-зомби становится init. И он автоматически выполняет wait, 
чтобы освободить ассоциируемые с процессом ресурсы. Таким образом слоты таблицы процессов в ядре не засоряется зомби и всё работает. 
Это перевод и осмысление вот этого:
дочерний процесс, который завершился, но для которого не был вызван wait, становится nак называемым зомби-процессом.
Ядро оставляет некоторое минимальное количество информации о таких процессах чтобы позволить родителю позднее
выполнить wait и получить эту информацию о дочернем процессе. Покуда зомби не удален из системы посредством wait, он 
будет занимать слот в таблице процессов в ядре, и, если эта таблица заполнена, это не позволит более создавать процессы. 
Но на такой случай есть защита: у любого процесса в UNIX, кроме init, есть родительский процесс. Так и тут: в случаях 
если: родительский процесс завершился без wait дочернего процесса, дочерний процесс завершился после родительского, 
init становится родителем для дочернего процесса, и автоматически выполняет wait, чтобы освободить ассоциируемые с 
процессом ресурсы


EXEC():
exec и его вариации позволяют подменить код и окружение одной программы кодом и окружением другой программы. То есть новый процесс не создается. 
Из иртеговской презентухи: подменяется часть текста - сразу после exec'a. И полностью подменяется все остальное виртуальное пространство: сегмент данных, динамические 
данные, BSS, стэк...

Нет возвращаемого значения, поскольку она не возвращает управление вызвавшей её программе. 

exec сначала проверяет, что файл можно исполнить

буковы:
e - Функция ожидает список переменных среды в виде вектора (envp []) и не использует список переменных текущей среды. 
v - аргументы программы подаются в виде массиваю 
p - используется переменная окружения в path. То есть можно использовать сокращенное имя файла, и будет поиск не только в текущей директории, но и в каталоге, соотв. 
path
l - переменные подаются списком 
Список используется, когда список аргументов известен на этапе компиляции. Вектор же, когда неизвестен. 

Что не наследуется: 
– Адресное пространство и отображенные на память файлы
– Пользовательские обработчики сигналов
– Регистры ЦПУ (контекст процесса)
– Нити исполнения
– euid/egid (если файл setuid или setgid, то соотв. эфф идент. не наследуются)

NULL в конце указывает на то, что аргументы закончились. 

Дополнительно:

Если execlp завершился успехом, то всё текущее адресное пространство заменяется на адресное пространство, созданное
на основе бинарного файла, который мы передали первым параметром и запускается новая программа.
Аргументы execlp копируются на дно стека.
Содержимое User Area у процесса почти не меняется, т.е. все файлы остаются открытыми.

(Вызов exec("exefile",...) загружает в память существующего процесса код и данные из файла exefile. Исполняемый файл 
exefile не занимает файловый дескриптор, но так же считается открытым, 
т.е. exec() увеличивает счётчик числа открытий в таблице виртуальных Inode)