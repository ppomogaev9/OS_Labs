Файловая система UNIX:
Файлы в файловой системе UNIX организованны в виде дерева, Каждый файл имеет имя. Имя не является свойством файла как такового, имя является атрибутом файла в файловой \
системе. В UNIX имя определяет положение файла в древовидной иерархии. 

Имя состоит из названия файла, а также тех директорий, которые необходимо пройти от корневого каталога "/" до нашего файла, в соответсвующем пути порядке.

Каждый файл имеет связанные с ним метаданные - данные, необходимые системе для работы с этим самым файлом. Это свойственно всем системам, и в каждой они реализуются по 
своему. 

ТИПЫ ФАЙЛОВ В UNIX: нужно для объяснения первого символа из 10-ти в ls -l
1) Обычный файл
2) Директория/каталог
3) Специальный файл устройства 
4) FIFO или именованный файл
5) Связь
6) Сокет

Файлы в UNIX имеют двух владельцев - пользователя и группу. С пользователем всё понятно. Группа - список пользователей системы. Списков может быть сколь угодно много, и
один пользователь не обязательно принадлежит одной группе. Пользователь всегда принадлежит как минимум одной группе(?) - первичной/основной(primary). Обычно, она 
называется также, как и пользователь. 

Важно отметить, что владелец файла не обязательно может состоять в группе, владеющей файлом. Самый простой способ достичь этого - быть выкинутым из той группы, в которой
состоял на момент создания файла(логично же? Ну всё это если в системе, в которой мы находимся, группа-владелец - группа, в которой был создатель файла на момент создания
может быть и не так. В некоторых версиях группа-владелец - это группа-владелец директории, в которой был создан файл). Оно и понятно, иначе права группы были бы тождественны
правам владельца файла. 

Естественным образом, файл создает процесс, как и запускает файл какой-то другой процесс, инициированный пользователем. Однако, у процесса есть атрибуты, несущие в себе
информацию о пользователе и будущей группе-владельце(зависит от системы). Они и служат для установки владельцев файла. 

Итак про IDшники:
Реальный идентификатор пользователя - это его ID - уникальный номер пользователя в системе. 
Эффективный идентификатор пользователя - от слова effective в значении действующий. Это тот, от имени которого была запущена программа. 

Маска прав доступа в linux представляет собой 12 бит. Первые три из которых - это SUID, SGID и sticky bit соответственно, далее идут по три бита на права владельца-пользователя, 
владельца-группы и всех остальных соответственно. В каждой из последних троек биты идут в следующем порядке: чтение, запись, исполнение. Устанавливать их можно при 
помощи команды chmod abcd file, где a,b,c,d - цифры от 0 до 7 включительно, соответствующие трем битам в нужном порядке. Хранится она, я так полагаю, в метаданных файла, 
так как это всё тот же атрибут файловой системы.

ДОПОЛНИТЕЛЬНЫЕ ФЛАГИ: 
SUID - если этот бит установлен, то при выполнении программы, id пользователя, от которого она запущена заменяется на uid владельца файла. 
SGID - этот флаг работает аналогичным образом, только разница в том, что пользователь считается членом группы-владельца файла
Sticky-bit - Установка атрибута Sticky bit для каталога позволяет установить дополнительную защиту файлов, находящихся в каталоге. Из такого каталога пользователь 
может удалить только файлы, которыми он владеет, или на которые он имеет явное право доступа на запись, даже при наличии права на запись в каталог.

Как работают права, в случае с директорией: 
Права доступа к папкам (директориям, или каталогам) дают совершать такие действия:
r — чтение (можно получить список имен объектов, входящих в каталог, но не их атрибутов, то есть, невозможен просмотр размеров файлов, прав доступа, имени владельца и т.д.);
w — изменение содержимого (создание, переименование и удаление объектов в директории, причем, удалять можно даже те файлы, право на запись для которых не установлено);
x — доступ в каталог (особенность здесь такая, что если даже вы имеете все необходимые права на файл, который расположен "в глубине директорий", но не имеете права 
доступа хотя бы к одной поддиректории на пути к этому объекту, то не сможете добраться до него), включая возможность просмотра атрибутов (свойств) файлов.

Первый символ: перевести
It means that it is a directory. The first mode field is the "special file" designator; regular files display as - (none). As for which possible letters could be there, on Linux the following exist:

d (directory)
c (character device)
l (symlink)
p (named pipe)
s (socket)
b (block device)
D (door, not common on Linux systems, but has been ported)

ДЕЛИГИРОВАНИЕ ПРАВ ПРИ ЗАПУСКЕ ПРОГРАММЫ
Положим мы запустили программу, и она открывает некоторый файл. Программа, запущенная нами, открывает файл от нашего имени, и, соответственно, имеет те же права, что и мы
Пример: 
touch file.txt
chmod 0 file.txt
cat file.txt

Здесь мы создали файл, обнулили права этого файла для всех, затем попросили программу cat вывести содержимое на экран. Результат ожидаем:
cat: cannot open file.txt: Permission denied

Мы обнулили права себе на чтение файла. Cat запускается от нашего имени, и имеет наши права, то есть, в данном случае, не может открыть файл на чтение. По итогу мы и 
получаем ошибку - отказ в доступе. 

Однако это всё работает, если не установлены первые три бита маски прав доступа.

Про используемые функции: 

fopen - возвращает не NULL, если все хорошо, и возвращает NULL, если нихуя не хорошо например файла нет такого.
fclose - возвращает 0, если всё хорошо и EOF, если не хорошо.
в обоих случаях errno устанавливается соотв. ошибке

getuid(2): uid_t getuid(void); возвращает реальный идентификатор вызвавшего данную функцию процесса 
geteuid(2): uid_t geteuid(void); возвращает эффективный идентификатор процесса, вызвавшего данную функцию.
У них нет ошибок, поэтому они всегда возвращают только описанное. 

Как уже было сказано, uid - свойство пользователя в файловой системе. Однако, у процесса есть атрибуты, которые перенимаются у вызывавшего его процесса. Поэтому имеет
смысл говорить про uid и euid. 

setuid(2): int setuid(uid_t uid) изменяет эффективный идентификатор вызывающего процесса, если аргумент функции uid совпадает с реальным идентификатором пользователя.

Изменение идентификаторов пользователя и группы:

Существуют определенные правила, согласно которым изменяются идентификаторы. Рассмотрим их на примере идентификатора пользователя. (Все перечисленное ниже в равной 
степени относится и к идентификатору группы.)

->Если процесс обладает привилегиями суперпользователя, функция setuid устанавливает реальный и эффективный идентификаторы пользователя в соответствии с аргументом uid.
->Если процесс не обладает привилегиями суперпользователя, но аргумент uid совпадает с реальным идентификатором пользователя, то setuid изменяет только эффективный 
идентификатор. Реальный и сохраненный идентификаторы не меняются.
->Если ни одно из этих условий не соблюдено, setuid возвращает значение (–1) и записывает в переменную errno код ошибки EPERM.

Суперпользователь: 
Root, он же суперпользователь, — это специальный аккаунт и группа пользователей в UNIX-подобных системах с идентификатором UID 0, владелец которого 
имеет право на выполнение всех без исключения операций. Суперпользователь UNIX-систем имеет логин «root» только по умолчанию и легко 
переименовывается при необходимости.
