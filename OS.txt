### - тема
## - подтема
# - заголовок
WIP - work in progress

Ссылки
Робочевский: 
http://parallels.nsu.ru/~fat/unixsvr4-new/trunk/%d0%90.%20%d0%a0%d0%be%d0%b1%d0%b0%d1%87%d0%b5%d0%b2%d1%81%d0%ba%d0%b8%d0%b9%20-%20%d0%9e%d0%bf%d0%b5%d1%80%d0%b0%d1%86%d0%b8%d0%be%d0%bd%d0%bd%d0%b0%d1%8f%20%d1%81%d0%b8%d1%81%d1%82%d0%b5%d0%bc%d0%b0%20UNIX.pdf
Иртегов UNIX System V Release 4: 
https://drive.google.com/uc?id=11UWu44xkYs7iN7BFx3Q-k1UJusHMz6N7
Лабы: 
https://docs.google.com/document/d/1242C_65gJ_8HscvJ4RolW09KGS-jieYWwomrRTK_bn0/edit
Исходный код соляриса: 
https://github.com/illumos/illumos-gate

Введение
В общем, программисты вынуждены, пусть и опосредованно, пользоваться сервисами операционной системы, да? Всей вот этой низкоуровневой мурой.
Но низкоуровневая херобора неидеальна - иногда сбоит, и это можно наблюдать при отладке или когда происходит какая-то муть с производительностью. Поэтому предлагается
разбираться во всем этом дерьме. 

на уровне, сравнимом с С, сервисы ОС выглядят как набор функций, представляемых системной(?) библиотекой, и как системные вызовы 

#определение Системные вызовы - это обращения к ядру ОС

#определение (WIKI) Ядро ОС (kernel) — центральная часть ОС обеспечивающая приложениям координированный доступ к ресурсам компьютера, таким как процессорное время, 
память, внешнее аппаратное обеспечение, внешнее устройство ввода и вывода информации.

Из этого: 
https://sun9-87.userapi.com/s/v1/ig2/4N5xE-fuanDOyWm4W5DvBeA5pQSeu4R7Y1Dqlv78QsVPi0WnS7w7C4hQN0IhxWbYKzBsnhn7VZeyJWCvsCUMUYJH.jpg?size=815x173&quality=96&type=album
Ядро обеспечивает доступ(регулирует взаимодействие с) к некоторым сервисам, таким как ввод/вывод и прочее, причем, судя по всему(надо проверить), ничто другое не имеет
на это непосредственного права. И чтобы получить доступ к этим сервисам пользователю, пишущему код, необходимо использовать стандартные библиотечные функции, которые
внутри содержат системный вызов к ядру ОС. Это делается так: процессору положено перейти в системный режим работы процессора(?(есть пользовательский режим)), передача
управления(?) ядру и копирование исходных параметров, переданных в функцию, в память ядра(?). Ядро проверяет права(?) на исполнение операции и, если таковые имеются,
исполняет требуемое с переданными данными(видимо далее как-то всё-таки все возвращается обратно).

Первый вопрос) (Источник информации Ванин brain!): Есть значит пользовательский режим работы процессора, в котором он имеет доступ только к пользовательской
памяти(семантика представлена где-то в другом месте), но не имеет доступ к памяти ядра. А есть системный режим работы, в котором у процессора появляется также доступ в
память ядра(проверить как-то). Если в пользовательском режиме процессор запросит информацию из ядра, то ему будет каким-то образом отказано в этом(ошибка какая-то 
будет)

Второй вопрос) (Источник инфы: мои догадки) Вероятно, исполнение программы ставится на паузу до выполнения соответствующего системного вызова ядром. Затем ядро же
предоставляет результат(может и не предоставлять - лучше об этом почитать) вызвавшей соотв. системный вызов функции и(идет отдыхать??? хз) 

Ввиду относительно, по сравнению с обычным вызовом функции, более высокой стоимости(время, полагаю), функции стандартной библиотеки пытаются сократить число таких
вызовов. Из-за высокой стоимости системных вызовов, например, является нежелательным считывание символов из файла или терминала по одному.

Работа ввода-вывода библиотечных функций по Иртегову: Библиотека(?, как библиотека может что-то предоставлять. Либо это просто такое высказывание, либо я не понимаю,
что такое библиотека) предоставляет буфер(поэтому ввод-вывод называется буферизованным) в пользовательской памяти(?. прочитать про типы памяти), к которому программа
может обращаться удобным для неё способом. Когда буфер опустеет(в случае со считыванием) или заполнится(в случае с непосимвольной, я полагаю, записью), программа
исполняет системный вызов и считывает или записывает новую порцию данных. 

Из книжки по операционкам от Вани: системный вызов меняет режим работы процессора с пользовательского(user) на системный(режим работы ядра, kernel mode), в котором 
процессор имеет доступ в защищенную память ядра
2) Множество системных вызовов фиксировано, и у каждого вызова есть свой уникальный номер, по которому его можно вызвать(сама схема нумерации для программы не видна, и 
программа вызывает соотв. вызов по имени(?)) 
3) Каждый системный вызов может содержать некоторый набор информации, который может быть передан из пользовательской памяти(т.е. виртуального адресного пространства 
соотв. процесса(?)) в память ядра и наоборот
Что происходит при системном вызове со стороны программы на примере x86-32: 
1) программа выполняет системный вызов путем вызова функции-оболочки этого вызова из стандартной библиотеки(? надо найти как там ) 
2) Оболочка должна сделать аргументы системного вызова доступными для некоей подпрограммы обработчика(the system call trap-handling routine)(типа это кратно, так 
что(?))(аргументы передаются через стэк, но ядро ожидает их в регистрах, так что обертка системного вызова - некая подпрограмма - копирует в регистры нужные данные) 
3) Процессору также необходимо определить, что за системный вызов. Для этого в предназначенный для этого регистр(для x86-32 это %eax) копируется номер системного 
вызова
4) программа-обертка выполняет машинную инструкцию прерывания(int 0x80), чтобы заставить процессор перейти из пользовательского режима в режим работы ядра(системный 
режим) 
бла-бла-бла лучше почитать в книжке

Короче:
1) вызывается функция-обертка системного вызова
2) обертка копирует переданные ей данные в регистры процессора
3) также обертка копирует уникальный номер системного вызова в регистр процессора
4) затем обертка выполняет некую машинную инструкцию прерывания, чтобы заставить процессор перейти в режим работы ядра(системный режим)
прерывание, как я понял, есть остановка работы программы с вызовом функции под названием обработчик прерывания, данные которой есть код системного вызова
проверяется, чтобы код действительно соответствовал системному вызову и если соответствует, то выполняется системный вызов
далее с результатом что-то происходит(дополнить и проверить предыдущее не под цифрами\)

Иртегов: "В UNIX все системные вызовы имеют функции-обертки в стандартной библиотеке языка С" 
Многие системные вызовы принимают аргументы, а также многие возвращают значение 
Если возникла ошибка в процессе исполнения кода соотв. системному вызову, то код ошибки(обычно -1) кладется в переменную(в новых системах препроцессорный макрос) errno

#тесты Относится к предыдущей картинке: я попробовал, и да, в errno.h, судя по всему, уже есть определение переменной errno как некоего целочисленного типа. Однако я 
хз что именно за тип у этой переменной 

#тесты usr/include/... лежат все заголовочные файлы, на случай, если будет интересно посмотреть чего-то

#тесты perror берет строчку по номеру ошибки, лежащем в errno, из sys_errlist и выводит в консоль следующее: "(поданная на вход строка):[sys_errlist[errno]]"

#тесты sys_errlist определен в stdio.h

#тесты usr/asm-generic/errno.h - описания всех(почти всех, там в другом прикрепленном файлике остаток) кодов ошибок, как я понял 

#тесты про errno его определение находится в usr/include/errno.h , только оно совсем непонятное, так что нахуй оно не нужно

###Ядро WIP
Прежде всего, ядро - это программа. 

По Робочевскому: Ядро обеспечивает базовую функциональность операционной системы: создает процессы и управляет ими, распределяет память и обеспечивает доступ к файлам 
и периферийным устройствам. 

Ядро обеспечивает прикладным программам(и не только) доступ к аппаратной части компьютера, а также предоставляет возможность пользоваться функционалом операционной 
системы, таким как создание процессов, менеджмент памятью(логично же, да? Confirmed), работа с вводом выводом. 

Структура ядра: 
https://sun9-43.userapi.com/s/v1/ig2/7vLUkb5NZ099L44iBMUBMCMbnvLGdZWkIUlAOS-6ixLqfoVK9zaAfnI7DURztPKK0Wdk6meCjVa03vfRNIWSwjjd.jpg?ze=354x362&quality=96&type=album
Про все её части можно почитать у Робочевского

https://en.wikipedia.org/wiki/Kernel_(operating_system)#cite_note-Linfo-1
Из википедии: ядро запускается одной из первых при запуске(boot) компьютера. (Судя по всему)Сразу после bootloader'a, который, в свою очередь является маленькой 
программой, находящейся в read-only memory(надо посмотреть где эта штука хранится. На википедии вроде указано) вместе с необходимыми данными для инициализации RAM, для 
инициализации ОЗУ (особенно в системах x86, так что проверить есть ли эта штука в UNIX), для доступа к nonvolatile(volatile - изменчивый, хз как это в программисткой 
теме) устройству (обычно блочному устройству, например, флэш-памяти NAND(посмотреть на вики, там вроде написано)) или устройствам, с которых программы и данные 
операционной системы могут быть загружены в ОЗУ.

##системные вызовы WIP
Интерфейс системных вызовов - набор системных вызовов. Системный вызов - обращение к ядру ОС. 
Картинка от иртегова: 
https://sun9-73.userapi.com/s/v1/ig2/kx8c09R2XEs7rwIHYAfRojPL-V_MmCBERihDnS6wl7BOFyoseSl2fug9bH22em-1O3Pary8sCDXkzFJq4McbRhE9.jpg?size=803x650&quality=96&type=album

Ядро взаимодействует с аппаратной частью посредством драйверов этой самой аппаратной части

###Процесс WIP
Картиночка от Иртегова: 
https://sun9-6.userapi.com/s/v1/ig2/ZbHIHs0tYgFzoaOXGiB5uo395GTyyjJPN7ZhsIcrvLm5kJYxLLD7yVqyEJXpFkNCbKfE-13yUXcMJVb4FNNzHXBG.jpg?size=538x818&quality=96&type=album

Процесс - это программа вместе с 

##Структура процесса WIP

###Виртуальная память WIP
Как я понял, каждому процессу выделяется некоторое виртуальное адресное пространство - набор чисел-адресов, отображаемых на физическое адресное пространство каким-то 
образом. Каким - решает часть ядра под названием модуль управления памятью. Отображение виртуального адресного пространства отдельного процесса на физическое - задача 
этого самого модуля управления памятью. Отображение может постоянно меняться. Более того, часть данных могут переносится из оперативной памяти во вторичную память(к 
примеру, специальную область жесткого диска(посмотреть как это связано с файлом подкачки)). На виртуальное адресное пространство это никак не влияет: все данные 
доступны по тем же виртуальным адресам, что и были до этого, в то время как физический адрес, скорее всего, не соответствует виртуальному, и более того, мог быть уже 
несколько раз изменен за время работы программы 

Отображение виртуальных адресов на физические происходит, в большинстве случаев, страничным образом: как известно, отображение - есть функция, . Страничный подход 
заключается в следующем: разобьем всю физическую память на куски одинаковой длины, виртуальное адресное пространство также. Единицей отображения будем считать этот 
самый кусок, который назовем страницей. Произвольному отображению соответствует страничное отображение с размером страницы - 1 бит 

##Конфликты. WIP
Как из написанного выше текста понятно, разные процессы могут быть отображены на одни и те же участки физической памяти(?может и нет, хз. Там в учебнике было про какие-то конфликты сказано, я так и не понял, что это значит). Как же это разрешается частью ядра - модулем управления памятью? ХЗ(выяснить как)
