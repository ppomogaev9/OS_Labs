Введение
В общем, программисты вынужден, пусть и опосредованно, пользоваться сервисами операционной системы, да? Всей вот этой низкоуровневой мурой.
Но низкоуровневая херобора неидеальна - иногда сбоит, и это можно наблюдать при отладке или когда происходит какая-то муть с производительностью. Поэтому предлагается разбираться во всем этом дерьме. 

на уровне, сравнимом с С, сервисы ОС выглядят как набор функций, представляемых системной(?) библиотекой, и как системные вызовы 

#определение Системные вызовы - это обращения к ядру ОС

#определение (WIKI) Ядро ОС (kernel) — центральная часть ОС обеспечивающая приложениям координированный доступ к ресурсам компьютера, таким как процессорное время, 
память, внешнее аппаратное обеспечение, внешнее устройство ввода и вывода информации.

Из этого: https://sun9-87.userapi.com/s/v1/ig2/4N5xE-fuanDOyWm4W5DvBeA5pQSeu4R7Y1Dqlv78QsVPi0WnS7w7C4hQN0IhxWbYKzBsnhn7VZeyJWCvsCUMUYJH.jpg?size=815x173&quality=96&type=album
Ядро обеспечивает доступ(регулирует взаимодействие с) к некоторым сервисам, таким как ввод/вывод и прочее, причем, судя по всему(надо проверить), ничто другое не имеет на это непосредственного права. И чтобы получить доступ к этим сервисам пользователю, пишущему код, необходимо использовать стандартные библиотечные функции, которые внутри содержат системный вызов к ядру ОС. Это делается так: процессору положено перейти в системный режим работы процессора(?(есть пользовательский режим)), передача управления(?) ядру и копирование исходных параметров, переданных в функцию, в память ядра(?). Ядро проверяет права(?) на исполнение операции и, если таковые имеются, исполняет требуемое с переданными данными(видимо далее как-то всё-таки все возвращается обратно).

Первый вопрос) (Источник информации Ванин brain!): Есть значит пользовательский режим работы процессора, в котором он имеет доступ только к пользовательской памяти(семантика представлена где-то в другом месте), но не имеет доступ к памяти ядра. А есть системный режим работы, в котором у процессора появляется также доступ в память ядра(проверить как-то). Если в пользовательском режиме процессор запросит информацию из ядра, то ему будет каким-то образом отказано в этом(ошибка какая-то будет)

Второй вопрос) (Источник инфы: мои догадки) Вероятно, исполнение программы ставится на паузу до выполнения соответствующего системного вызова ядром. Затем ядро же предоставляет результат(может и не предоставлять - лучше об этом почитать) вызвавшей соотв. системный вызов функции и(идет отдыхать??? хз) 

Ввиду относительно, по сравнению с обычным вызовом функции, более высокой стоимости(время, полагаю), функции стандартной библиотеки пытаются сократить число таких вызовов. Из-за высокой стоимости системных вызовов, например, является нежелательным считывание символов из файла или терминала по одному.

Работа ввода-вывода библиотечных функций по Иртегову: Библиотека(?, как библиотека может что-то предоставлять. Либо это просто такое высказывание, либо я не понимаю, что такое библиотека) предоставляет буфер(поэтому ввод-вывод называется буферизованным) в пользовательской памяти(?. прочитать про типы памяти), к которому программа может обращаться удобным для неё способом. Когда буфер опустеет(в случае со считыванием) или заполнится(в случае с непосимвольной, я полагаю, записью), программа исполняет системный вызов и считывает или записывает новую порцию данных. 

Из книжки по операционкам от Вани: системный вызов меняет режим работы процессора с пользовательского(user) на системный(режим работы ядра, kernel mode), в котором процессор имеет доступ в защищенную память ядра
2) Множество системных вызовов фиксировано, и у каждого вызова есть свой уникальный номер, по которому его можно вызвать(сама схема нумерации для программы не видна, и программа вызывает соотв. вызов по имени(?)) 
3) Каждый системный вызов может содержать некоторый набор информации, который может быть передан из пользовательской памяти(т.е. виртуального адресного пространства соотв. процесса(?)) в память ядра и наоборот
Что происходит при системном вызове со стороны программы на примере x86-32: 
1) программа выполняет системный вызов путем вызова функции-оболочки этого вызова из стандартной библиотеки(? надо найти как там ) 
2) Оболочка должна сделать аргументы системного вызова доступными для некоей подпрограммы обработчика(the system call trap-handling routine)(типа это кратно, так что(?))(аргументы передаются через стэк, но ядро ожидает их в регистрах, так что обертка системного вызова - некая подпрограмма - копирует в регистры нужные данные) 
3) Процессору также необходимо определить, что за системный вызов. Для этого в предназначенный для этого регистр(для x86-32 это %eax) копируется номер системного вызова
4) программа-обертка выполняет машинную инструкцию прерывания(int 0x80), чтобы заставить процессор перейти из пользовательского режима в режим работы ядра(системный режим) 
бла-бла-бла лучше почитать в книжке

Короче:
1) вызывается функция-обертка системного вызова
2) обертка копирует переданные ей данные в регистры процессора
3) также обертка копирует уникальный номер системного вызова в регистр процессора
4) затем обертка выполняет некую машинную инструкцию прерывания, чтобы заставить процессор перейти в режим работы ядра(системный режим)
прерывание, как я понял, есть остановка работы программы с вызовом функции под названием обработчик прерывания, данные которой есть код системного вызова
проверяется, чтобы код действительно соответствовал системному вызову и если соответствует, то выполняется системный вызов
далее с результатом что-то происходит(дополнить и проверить предыдущее не под цифрами\)

Иртегов: "В UNIX все системные вызовы имеют функции-обертки в стандартной библиотеке языка С" 
Многие системные вызовы принимают аргументы, а также многие возвращают значение 
Если возникла ошибка в процессе исполнения кода соотв. системному вызову, то код ошибки(обычно -1) кладется в переменную(в новых системах препроцессорный макрос) errno

#тесты Относится к предыдущей картинке: я попробовал, и да, в errno.h, судя по всему, уже есть определение переменной errno как некоего целочисленного типа. Однако я хз что именно за тип у этой переменной 

#тесты usr/include/... лежат все заголовочные файлы, на случай, если будет интересно посмотреть чего-то

#тесты perror берет строчку по номеру ошибки, лежащем в errno, из sys_errlist и выводит в консоль следующее: "(поданная на вход строка):[sys_errlist[errno]]"

#тесты sys_errlist определен в stdio.h

#тесты usr/asm-generic/errno.h - описания всех(почти всех, там в другом прикрепленном файлике остаток) кодов ошибок, как я понял 

#тесты про errno его определение находится в usr/include/errno.h , только оно совсем непонятное, так что нахуй оно не нужно
